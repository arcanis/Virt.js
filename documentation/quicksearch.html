<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"inputs_AggregateInput.js.html":{"id":"inputs_AggregateInput.js.html","title":"Source: inputs/AggregateInput.js","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Source: inputs/AggregateInput.js export class AggregateInput { /** * An AggregateInput is an input device that combines multiple other inputs together. * * @constructor * @implements {Input} * * @param {Input[]} [sources] - The initial sources used for the aggregate. */ constructor(sources = []) { this.inputs = []; for (let source of sources) { this.addSource(source); } } /** * Add a new input source inside the aggregate. * * @param {Input} input - The input to aggregate. */ addSource(input) { if (this.inputs.includes(input)) return; this.inputs.push(input); } /** * Remove an input source from the aggregate. * * @param {Input} input - The input to remove. */ removeSource(input) { let index = this.inputs.indexOf(input); this.inputs.splice(index, 1); } /** * Simultaneously poll each aggregated input. */ pollInputs() { for (let input of this.inputs) { input.pollInputs(); } } /** * Returns true if any of the aggregated input should return true. * * @param {number} port - The input slot controller. * @param {number} code - The input slot code. */ getState(port, code) { for (let input of this.inputs) if (input.getState(port, code)) return true; return false; } } × Search results Close "},"timers_AnimationFrameTimer.js.html":{"id":"timers_AnimationFrameTimer.js.html","title":"Source: timers/AnimationFrameTimer.js","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Source: timers/AnimationFrameTimer.js import { AsyncTimer } from './AsyncTimer'; export class AnimationFrameTimer extends AsyncTimer { /** * An AnimationFrameTimer is timer device that makes use of the requestAnimationFrame/cancelAnimationFrame API from modern browsers to trigger asynchronous ticks. * * @constructor */ constructor() { // eslint-disable-line no-useless-constructor super(); } prepare(callback) { return window.requestAnimationFrame(callback); } cancel(animationFrameId) { window.cancelAnimationFrame(animationFrameId); } } × Search results Close "},"timers_AsyncTimer.js.html":{"id":"timers_AsyncTimer.js.html","title":"Source: timers/AsyncTimer.js","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Source: timers/AsyncTimer.js import { SerialTimer } from 'virtjs/devices/timers/SerialTimer'; import { makeFastTick } from 'virtjs/devices/timers/utils'; export class AsyncTimer { /** * An AsyncTimer is an asynchronous timer device. You can use it to run your emulator without blocking your main thread. However, unless you really want to implement a new asynchronous device on top of a new API, you're probably looking for {@link AnimationFrameTimer} for browser environments, or {@link ImmediateTimer} for Node.js environments. * * @constructor * @implements {Timer} * * @param {object} [options] - The timer options. * @param {function} [options.prepare] - The callback that will schedule the next cycle * @param {function} [options.cancel] - The callback that will abort the next cycle * * @see {@link AnimationFrameTimer} * @see {@link ImmediateTimer} */ constructor({ prepare, cancel } = { }) { if (prepare) this.prepare = prepare; if (cancel) this.cancel = cancel; this.running = false; this.nested = false; this.loopHandler = null; this.fastLoop = null; this.timer = new SerialTimer(); } nextTick(callback) { return this.timer.nextTick(callback); } cancelTick(handler) { return this.timer.cancelTick(handler); } start(beginning, ending) { if (this.running) throw new Error(`You can't start a timer that is already running`); if (this.nested) throw new Error(`You can't start a timer from its callbacks - use resume instead`); this.running = true; let resolve; let reject; let promise = new Promise((resolveFn, rejectFn) =&gt; { resolve = resolveFn; reject = rejectFn; }); let fastTick = makeFastTick(beginning, ending, () =&gt; { this.timer.one(); }); let mainLoop = () =&gt; { if (!this.running) { resolve(); } else try { this.prepare(mainLoop); this.nested = true; fastTick(); this.nested = false; } catch (e) { this.running = false; this.nested = false; reject(e); } }; this.prepare(mainLoop); return promise; } resume() { if (!this.nested) throw new Error(`You can't resume a timer from anywhere else than its callbacks - use start instead`); if (this.running) return; this.running = true; } stop() { if (!this.running) return; this.running = false; } /** * This method should be specialized, either via subclassing, or by passing the proper parameter when instanciating the timer. * * @protected * * @type {prepareCallback} */ prepare() { throw new Error(`Unimplemented`); } /** * This method should be specialized, either via subclassing, or by passing the proper parameter when instanciating the timer. * * @protected * * @type {cancelCallback} */ cancel() { throw new Error(`Unimplemented`); } } × Search results Close "},"timers_Timer.js.html":{"id":"timers_Timer.js.html","title":"Source: timers/Timer.js","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Source: timers/Timer.js /** * @name Timer * @interface */ /** * An engine will call this function if it wants to schedule a function to be called at the next tick. * * @method * @name Timer#nextTick * * @param {function} fn - The function that should be registered. * @return {Opaque} handler */ /** * An engine will call this function if it wants to prevent a scheduled function from being executed. * * @method * @name Timer#cancelTick * * @param {Opaque} handler - The handler returned by {@link Timer#nextTick}. */ /** * Start the timer. * * @method * @name Timer#start * * @param {function} [beginning] - An optional function that will be called before each tick. * @param {function} [ending] - An optional function that will be caled after each tick. */ /** * Stop the timer. * * @method * @name Timer#stop */ × Search results Close "},"audio_Audio.js.html":{"id":"audio_Audio.js.html","title":"Source: audio/Audio.js","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Source: audio/Audio.js /** * @name Audio * @interface */ /** * An engine will call this function to check if the device supports the specified input format. * * Return true if the audio device supports the specified input format. * * @method * @name Audio#validateInputFormat * * @param {AudioInputFormat} format - The input format to validate. */ /** * An engine will call this function to inform the device of the new input format. * * Throw an exception if the audio device doesn't support the new input format. * * @method * @name Audio#setInputFormat * * @param {AudioInputFormat} format - The new input format. */ /** * An engine will call this function to send samples that the audio device will queue to be played. * * Regardless of the input format, the samples are expected to be interlaced (for example, a mono stream will have [left, left, left], whereas a stereo stream will have [left, right, left, right, left, right]). * * @param {number[]} samples - The samples to queue. */ × Search results Close "},"timers_ImmediateTimer.js.html":{"id":"timers_ImmediateTimer.js.html","title":"Source: timers/ImmediateTimer.js","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Source: timers/ImmediateTimer.js import { AsyncTimer } from './AsyncTimer'; export class ImmediateTimer extends AsyncTimer { /** * An ImmediateTimer is a timer device that makes use of the setImmediate/clearImmediate API from Node to trigger aynchronous ticks. * * @constructor */ constructor() { // eslint-disable-line no-useless-constructor super(); } prepare(callback) { return setImmediate(callback); } cancel(handler) { clearImmediate(handler); } } × Search results Close "},"inputs_Input.js.html":{"id":"inputs_Input.js.html","title":"Source: inputs/Input.js","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Source: inputs/Input.js /** * @name Input * @interface */ /** * An engine will call this function to inform the device that it should update the input state. * * It means that the devices should never update the input state by themselves, but rather wait for the engine order. It is also important that the update is done synchronously, so that right after returning, the engines are able to call {@link Input#getState}. * * @method * @name Input#pollInputs */ /** * An engine will call this function to check the current state of a specified input. The function will return true if the input is currently active (pressed), and false otherwise. * * @method * @name Input#getState * * @param {number} port - The input controller port. * @param {number} code - The input code. */ × Search results Close "},"inputs_KeyboardInput.js.html":{"id":"inputs_KeyboardInput.js.html","title":"Source: inputs/KeyboardInput.js","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Source: inputs/KeyboardInput.js import { ManualInput } from 'virtjs/devices/inputs/ManualInput'; let DEFAULT_KEY_MAP = { /* eslint-disable no-magic-numbers */ 37: [ 0, `LEFT` ], // arrow left 39: [ 0, `RIGHT` ], // arrow right 38: [ 0, `UP` ], // arrow up 40: [ 0, `DOWN` ], // arrow down 65: [ 0, `A` ], // 'A' 81: [ 0, `A` ], // 'Q' 90: [ 0, `B` ], // 'Z' 87: [ 0, `B` ], // 'W' 66: [ 0, `B` ], // 'B' 76: [ 0, `L` ], // 'L' 82: [ 0, `R` ], // 'R' 13: [ 0, `START` ], // enter 8: [ 0, `SELECT` ], // backspace 32: [ 0, `SELECT` ] // space /* eslint-enable no-magic-numbers */ }; export class KeyboardInput { /** * A KeyboardInput is an input device that will monitor the keystrokes on a specified DOM element and transmit those actions to the engines. * * @constructor * @implements {Input} * * @param {object} [options] - The device options. * @param {Element} [options.element] - The element on which will be bound the DOM listeners. * @param {KeyMap} [options.keyMap] - The initial key map. */ constructor({ element = document.body, keyMap = DEFAULT_KEY_MAP, inputMap = null } = {}) { /** * This value contains the element on which the DOM listeners have been bound. * * @member * @readonly * @type {Element} */ this.element = null; /** * This value contains the current key map used to filter keys. * * @member * @readonly * @type {KeyMap} */ this.keyMap = null; this.input = new ManualInput({ inputMap }); this.onKeyDown = this.onKeyDown.bind(this); this.onKeyUp = this.onKeyUp.bind(this); this.setKeyMap(keyMap); this.setElement(element); } /** * Change the element on which are bound the DOM listeners. */ setElement(element) { if (element === this.element) return; if (this.element !== null) this.detachEvents(); this.element = element; if (this.element !== null) { this.attachEvents(); } } /** * Set the key map that will be used to translate key codes into inputs. * * Any old key that doesn't map to the same input anymore will be automatically released. * * @param {KeyMap} keyMap - The new key map. */ setKeyMap(keyMap) { if (keyMap === this.keyMap) return; if (this.keyMap) { for (let key of Reflect.ownKeys(this.keyMap)) { let [ port, code ] = this.keyMap[key]; if (keyMap &amp;&amp; Reflect.has(keyMap, key) &amp;&amp; keyMap[key][0] === port &amp;&amp; keyMap[key][1] === code) continue; this.input.up(port, code); } } this.keyMap = keyMap; } /** * @borrows ManualInput#setCodeMap as KeyboardInput#setCodeMap */ setCodeMap(codeMap) { this.input.setCodeMap(codeMap); } pollInputs() { this.input.pollInputs(); } getState(port, code) { return this.input.getState(port, code); } attachEvents() { this.element.addEventListener(`keydown`, this.onKeyDown); this.element.addEventListener(`keyup`, this.onKeyUp); } detachEvents() { this.element.removeEventListener(`keydown`, this.onKeyDown); this.element.removeEventListener(`keyup`, this.onKeyUp); } onKeyDown(e) { if ([ `select`, `input`, `textarea` ].includes(e.target.tagName.toLowerCase())) return; if (e.keyCode === 8 /* backspace */) // eslint-disable-line no-magic-numbers e.preventDefault(); if (e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) return; if (!Reflect.has(this.keyMap, e.keyCode)) return; e.preventDefault(); let [ port, code ] = this.keyMap[e.keyCode]; this.input.down(port, code); } onKeyUp(e) { if (!Reflect.has(this.keyMap, e.keyCode)) return; let [ port, code ] = this.keyMap[e.keyCode]; this.input.up(port, code); } } × Search results Close "},"inputs_ManualInput.js.html":{"id":"inputs_ManualInput.js.html","title":"Source: inputs/ManualInput.js","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Source: inputs/ManualInput.js export class ManualInput { /** * A ManualInput is an input device that will transmit any state you manually set from a Javascript API. It's a strictly better {@link NullInput}, that works on any environment while still giving you a way to trigger some events when you need to. * * @constructor * @implements {Input} * * @param {object} [options] - The device options. * @param {object} [options.codeMap] - The initial code map. */ constructor({ codeMap = null } = {}) { /** * This value contains the current code map used to translate codes. * * @member * @readonly * @type {object} */ this.codeMap = null; this.devices = {}; this.pending = {}; this.setCodeMap(codeMap); } /** * Set the code map that will be used to translate input codes from one to another. * * @param {object} codeMap - The new input map. */ setCodeMap(codeMap) { if (codeMap === this.codeMap) return; this.codeMap = codeMap; } /** * Set an input slot as being pressed. * * @param {number} port - The input slot controller port. * @param {number} code - The input slot code. */ down(port, code) { if (this.codeMap) code = this.codeMap[code]; this.pending[port] = this.pending[port] || {}; this.pending[port][code] = true; } /** * Set an input slot as being released. * * @param {number} port - The input slot controller port. * @param {number} code - The input slot code. */ up(port, code) { if (this.codeMap) code = this.codeMap[code]; this.pending[port] = this.pending[port] || {}; this.pending[port][code] = false; } pollInputs() { let pending = this.pending; this.pending = {}; for (let port of Reflect.ownKeys(pending)) { for (let code of Reflect.ownKeys(pending[port])) { this.devices[port] = this.devices[port] || {}; this.devices[port][code] = pending[port][code]; } } } getState(port, code) { return Boolean(this.devices[port] &amp;&amp; this.devices[port][code]); } } × Search results Close "},"audio_NullAudio.js.html":{"id":"audio_NullAudio.js.html","title":"Source: audio/NullAudio.js","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Source: audio/NullAudio.js export class NullAudio { /** * A NullAudio is an audio device that won't play anything. * * @constructor * @implements {Audio} */ constructor() { // eslint-disable-line no-useless-constructor // nothing } validateInputFormat(format) { return true; } setInputFormat(format) { // nothing } pushSampleBatch(samples) { // nothing } } × Search results Close "},"inputs_NullInput.js.html":{"id":"inputs_NullInput.js.html","title":"Source: inputs/NullInput.js","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Source: inputs/NullInput.js export class NullInput { /** * A NullInput is an input device that will never transmit any key as pressed. Even if you don't want any fancy keyboard support or similar, {@link ManualInput} is probably a better candidate than NullInput since the later allows you to programmatically trigger key events should you need to, whereas NullInput will never ever do anything. * * @constructor * @implements {Input} */ constructor() { // eslint-disable-line no-useless-constructor // nothing } pollInputs() { // nothing } getState(port, inputCode) { return false; } } × Search results Close "},"screens_NullScreen.js.html":{"id":"screens_NullScreen.js.html","title":"Source: screens/NullScreen.js","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Source: screens/NullScreen.js export class NullScreen { /** * A NullScreen is a screen device that doesn't actually render anything. It might be useful if you want to run an engine on Node. * * @constructor * @implements {Screen} */ constructor() { this.inputWidth = 0; this.inputHeight = 0; this.inputPitch = 0; this.inputFormat = null; this.inputData = null; this.outputWidth = 0; this.outputHeight = 0; } validateInputFormat(format) { return true; } setInputFormat(format) { this.inputFormat = format; } setInputSize(width, height, pitch = width) { this.inputWidth = width; this.inputHeight = height; this.inputPitch = pitch; } setInputData(data) { this.inputData = data; } setOutputSize(width, height) { this.outputWidth = width; this.outputHeight = height; } flushScreen() { // nothing } } × Search results Close "},"screens_Screen.js.html":{"id":"screens_Screen.js.html","title":"Source: screens/Screen.js","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Source: screens/Screen.js /** * @name Screen * @interface */ /** * This value contains the width of the input that the screen is expecting to render. * * Use {@link Screen#setInputSize} to change it. * * @member * @readonly * @name Screen#inputWidth * @type {number} */ /** * This value contains the height of the input that the screen is expecting to render. * * Use {@link Screen#setInputSize} to change it. * * @member * @readonly * @name Screen#inputHeight * @type {number} */ /** * This value contains the pitch of the input that the screen is expecting to render. * * The pitch is the actual amount of data in a pixel row. Some engines add extra data after each row in order to align the data size. * * Use {@link Screen#setInputSize} to change it. * * @member * @readonly * @name Screen#inputPitch * @type {number} */ /** * This value contains the input format that the screen is expecting to render. * * Use {@link Screen#setInputFormat} to change it. * * @member * @readonly * @name Screen#inputFormat * @type {ScreenInputFormat} */ /** * This value contains the data that the screen is currently rendering. * * Use {@link Screen#setInputData} to change it. * * @member * @readonly * @name Screen#inputData * @type {*} */ /** * This value contains the output width of the rendered data. * * Use {@link Screen#setOutputSize} to change it. * * @member * @readonly * @name Screen#outputWidth * @type {number} */ /** * This value contains the output height of the rendered data. * * Use {@link Screen#setOutputSize} to change it. * * @member * @readonly * @name Screen#outputHeight * @type {number} */ /** * An engine will call this function to inform the device of the new input size. * * @method * @name Screen#setInputSize * * @param {number} width - The new input width. * @param {number} height - The new input height. * @param {number} [pitch] - The new input pitch. */ /** * An engine will call this function to check if the device supports the specified input format. * * Return true if the screen device supports the specified input format. * * @method * @name Screen#validateInputFormat * * @param {ScreenInputFormat} format - The input format to validate. * * @return {bool} */ /** * An engine will call this function to inform the device of the new input format. * * Throw an exception if the screen device doesn't support the new input format. * * @method * @name Screen#setInputFormat * * @param {ScreenInputFormat} format - The new input format. */ /** * An engine will call this function to inform the device of the new input data. * * @method * @name Screen#setInputData * * @param {*} data - The new input data. */ /** * Change the output size. * * @method * @name Screen#setOutputSize * * @param {number} width - The new output width. * @param {number} height - The new output height. */ /** * Render the input data on the screen. * * @method * @name Screen#flushScreen */ × Search results Close "},"timers_NullTimer.js.html":{"id":"timers_NullTimer.js.html","title":"Source: timers/NullTimer.js","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Source: timers/NullTimer.js export class NullTimer { /** * A NullTimer is a timer device that will never tick. You probably don't want to use it. If you're looking for a synchronous timer, check {@link SerialTimer} instead. If you're looking for an asynchronous timer that works on Node.js, check {@link ImmediateTimer} instead. If you're looking for a synchronous timer that works on Node.js, check {@link SerialTimer} instead. * * @constructor * @implements {Timer} * * @see {@link SerialTimer} */ constructor() { // eslint-disable-line no-useless-constructor // nothing } nextTick(callback) { // nothing } cancelTick(nextTickId) { // nothing } start(beginning, ending) { return new Promise(() =&gt; {}); } stop() { // nothing } } × Search results Close "},"timers_SerialTimer.js.html":{"id":"timers_SerialTimer.js.html","title":"Source: timers/SerialTimer.js","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Source: timers/SerialTimer.js import { makeFastTick } from 'virtjs/devices/timers/utils'; let HANDLER_FN_SIZE = 31; let HANDLER_FN_PATTERN = 0x7FFFFFFF; export class SerialTimer { /** * A SerialTimer is a synchronous timer device. You can use it to run your emulator synchronously (ie. blocking the main thread). It also has the ability to only run a finite number of ticks before returning, which is quite valuable when debugging engines. * * @constructor * @implements {Timer} */ constructor() { this.running = false; this.nested = false; this.queues = [ [ ], [ ] ]; this.activeQueueIndex = 0; } nextTick(callback) { let activeQueueIndex = this.activeQueueIndex; let queue = this.queues[activeQueueIndex]; let callbackIndex = queue.length; queue.push(callback); return activeQueueIndex &lt;&lt; HANDLER_FN_SIZE | callbackIndex; } cancelTick(handler) { let activeQueueIndex = handler &gt;&gt;&gt; HANDLER_FN_SIZE; let callbackIndex = handler &amp; HANDLER_FN_PATTERN; this.queues[activeQueueIndex][callbackIndex] = null; } start(beginning, ending) { if (this.running) throw new Error(`You can't start a timer that is already running`); if (this.nested) throw new Error(`You can't start a timer from its callbacks - use resume instead`); let fastTick = makeFastTick(beginning, ending, () =&gt; { this.one(); }); this.running = true; this.nested = true; while (this.running) fastTick(); this.nested = false; } resume() { if (!this.nested) throw new Error(`You can't resume a timer from anywhere else than its callbacks - use start instead`); if (this.running) return; this.running = true; } stop() { if (!this.running) return; this.running = false; } /** * Start the emulator. Run a single cycle then exit. */ one() { let activeQueueIndex = this.activeQueueIndex; this.activeQueueIndex = activeQueueIndex ^ 1; let queue = this.queues[activeQueueIndex]; for (let t = 0, T = queue.length; t &lt; T; ++t) queue[t] &amp;&amp; queue[t](); queue.length = 0; } } × Search results Close "},"screens_WebGLScreen.js.html":{"id":"screens_WebGLScreen.js.html","title":"Source: screens/WebGLScreen.js","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Source: screens/WebGLScreen.js let BITS_PER_BYTE = 8; let RENDER_DEPTH = 100; let TYPED_VIEW = Symbol(); let GL_FORMAT = Symbol(); let GL_TYPE = Symbol(); let gWebGlSupportedInputFormats = [ { depth: 16, rMask: 0b1111100000000000, gMask: 0b0000011111100000, bMask: 0b0000000000011111, aMask: 0b0000000000000000, [TYPED_VIEW]: Uint16Array, [GL_FORMAT]: `RGB`, [GL_TYPE]: `UNSIGNED_SHORT_5_6_5` } ]; let gVertexShaderScript = ` precision mediump float; uniform mat4 uMatrix; attribute vec3 aVertexPosition; attribute vec2 aVertexTextureUv; varying vec2 vTextureCoordinates; void main( void ) { vTextureCoordinates = vec2( aVertexTextureUv.s, 1.0 - aVertexTextureUv.t ); gl_Position = uMatrix * vec4( aVertexPosition, 1.0 ); } `; let gFragmentShaderScript = ` precision mediump float; uniform sampler2D uScreenTexture; varying vec2 vTextureCoordinates; void main( void ) { gl_FragColor = texture2D( uScreenTexture, vTextureCoordinates ); } `; function getMatchingInputFormat({ depth, rMask, gMask, bMask, aMask }) { for (let supported of gWebGlSupportedInputFormats) if (depth === supported.depth &amp;&amp; rMask === supported.rMask &amp;&amp; gMask === supported.gMask &amp;&amp; bMask === supported.bMask &amp;&amp; aMask === supported.aMask) return supported; return null; } function makeCanvasGlBuilder(canvas, options) { return () =&gt; { return canvas.getContext(`webgl`, options) || canvas.getContext(`experimental-webgl`, options); }; } export class WebGLScreen { /** * A WebGLScreen is a screen device that uses a WebGL canvas as rendering target. Note that you can also use a headless-gl instance as rendering context, in which case you can simply pass null as canvas parameter. * * @constructor * @implements {Screen} * * @param {object} [options] - The screen options. * @param {CanvasElement} [options.canvas] - The target canvas. * @param {object} [options.glOptions] - The extra option used to setup the WebGL context. * @param {function} [options.glBuilder] - A factory that will build the WebGL context. */ constructor({ canvas = document.createElement(`canvas`), glOptions = null, glBuilder = makeCanvasGlBuilder(canvas, glOptions) } = { }) { /** * The target canvas on which will be rendered the input data. * * @member * @readonly * @type {CanvasElement} */ this.canvas = canvas; /** * The WebGL context used to render the input data. * * @member * @readonly * @type {WebGLRenderingContext} */ this.gl = null; this.inputWidth = 0; this.inputHeight = 0; this.inputPitch = 0; this.inputFormat = null; this.inputData = null; this.outputWidth = 0; this.outputHeight = 0; this.pitchedInputData = null; this.shaderProgram = null; this.uMatrixLocation = null; this.uScreenTextureLocation = null; this.uInputResolutionLocation = null; this.uOutputResolutionLocation = null; this.aVertexPositionLocation = null; this.aVertexTextureUvLocation = null; this.textureIndex = 0; this.setupGl(glBuilder); let boundingBox = this.canvas &amp;&amp; this.canvas.getBoundingClientRect(); let { width, height } = boundingBox || { width: 100, height: 100 }; this.setInputSize(width, height); this.setOutputSize(width, height); } setInputSize(width, height, pitch = width) { if (width === null &amp;&amp; height === null) throw new Error(`Input width, height, and pitch cannot be null`); if (width === this.inputWidth &amp;&amp; height === this.inputHeight &amp;&amp; pitch === this.inputPitch) return; this.inputWidth = width; this.inputHeight = height; this.inputPitch = pitch; this.setupAlignmentBuffer(); this.updateViewport(); this.draw(); } setOutputSize(width = null, height = null) { if (width === this.outputWidth &amp;&amp; height === this.outputHeight) return; this.outputWidth = width; this.outputHeight = height; this.updateViewport(); this.draw(); } setShaderProgram(shaderProgram) { if (shaderProgram === this.shaderProgram) return; if (this.shaderProgram !== null) this.gl.deleteProgram(this.shaderProgram); this.shaderProgram = shaderProgram; this.gl.useProgram(shaderProgram); this.uMatrixLocation = this.gl.getUniformLocation(shaderProgram, `uMatrix`); this.uScreenTextureLocation = this.gl.getUniformLocation(shaderProgram, `uScreenTexture`); this.gl.uniform1i(this.uScreenTextureLocation, 0); this.uInputResolutionLocation = this.gl.getUniformLocation(shaderProgram, `uInputResolution`); this.uOutputResolutionLocation = this.gl.getUniformLocation(shaderProgram, `uOutputResolution`); this.uViewportResolutionLocation = this.gl.getUniformLocation(shaderProgram, `uViewportResolution`); this.aVertexPositionLocation = this.gl.getAttribLocation(shaderProgram, `aVertexPosition`); this.gl.enableVertexAttribArray(this.aVertexPositionLocation); this.aVertexTextureUvLocation = this.gl.getAttribLocation(shaderProgram, `aVertexTextureUv`); this.gl.enableVertexAttribArray(this.aVertexTextureUvLocation); this.gl.bindBuffer(this.vertexPositionBuffer.bufferTarget, this.vertexPositionBuffer); this.gl.vertexAttribPointer(this.aVertexPositionLocation, this.vertexPositionBuffer.itemSize, this.gl.FLOAT, false, 0, 0); this.gl.bindBuffer(this.vertexTextureUvBuffer.bufferTarget, this.vertexTextureUvBuffer); this.gl.vertexAttribPointer(this.aVertexTextureUvLocation, this.vertexTextureUvBuffer.itemSize, this.gl.FLOAT, false, 0, 0); } validateInputFormat(format) { return getMatchingInputFormat(format) !== null; } setInputFormat(partialFormat) { let fullFormat = getMatchingInputFormat(partialFormat); if (!fullFormat) throw new Error(`Invalid input format`); this.inputFormat = fullFormat; this.setupAlignmentBuffer(); } setInputData(data) { if (!data) return; this.inputData = data; } flushScreen() { this.draw(); } createTexture() { let texture = this.gl.createTexture(); return texture; } createBuffer(target, count, content) { let buffer = this.gl.createBuffer(); buffer.bufferTarget = target; buffer.itemCount = count; buffer.itemSize = content.length / count; this.gl.bindBuffer(buffer.bufferTarget, buffer); this.gl.bufferData(buffer.bufferTarget, content, this.gl.STATIC_DRAW); return buffer; } createOrthoMatrix(left, right, bottom, top, near, far) { let lr = 1 / (left - right); let bt = 1 / (bottom - top); let nf = 1 / (near - far); /* eslint-disable no-magic-numbers */ return [ -2 * lr, 0, 0, 0, 0, -2 * bt, 0, 0, 0, 0, 2 * nf, 0, (left + right) * lr, (bottom + top) * bt, (near + far) * nf, 1 ]; /* eslint-enable no-magic-numbers */ } setupBuffers() { /* eslint-disable no-magic-numbers */ this.vertexPositionBuffer = this.createBuffer(this.gl.ARRAY_BUFFER, 4, new Float32Array([ -1, -1, 0, /**/ 1, -1, 0, /**/ 1, 1, 0, /**/ -1, 1, 0 ])); this.vertexTextureUvBuffer = this.createBuffer(this.gl.ARRAY_BUFFER, 4, new Float32Array([ 0, 0, /**/ 1, 0, /**/ 1, 1, /**/ 0, 1 ])); this.vertexIndexBuffer = this.createBuffer(this.gl.ELEMENT_ARRAY_BUFFER, 4, new Uint16Array([ 0, 1, 3, 2 ])); /* eslint-enable no-magic-numbers */ } setupShaders() { this.fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, gFragmentShaderScript); this.vertexShader = this.createShader(this.gl.VERTEX_SHADER, gVertexShaderScript); this.linkShaders(this.fragmentShader, this.vertexShader); } setupTextures() { this.gl.activeTexture(this.gl.TEXTURE0); this.textures = [ this.createTexture(), this.createTexture() ]; this.textures.forEach(texture =&gt; { this.gl.bindTexture(this.gl.TEXTURE_2D, texture); this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST); this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST); this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE); this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE); }); } setupGl(glBuilder) { this.gl = glBuilder(); this.gl.clearColor(0, 0, 0, 0); this.setupBuffers(); this.setupShaders(); this.setupTextures(); } createShader(type, script) { let shader = this.gl.createShader(type); this.gl.shaderSource(shader, script); this.gl.compileShader(shader); if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) throw new Error(`Shader compilation failed: ${this.gl.getShaderInfoLog(shader)}`); return shader; } linkShaders(vertexShader, fragmentShader) { let shaderProgram = this.gl.createProgram(); this.gl.attachShader(shaderProgram, vertexShader); this.gl.attachShader(shaderProgram, fragmentShader); this.gl.linkProgram(shaderProgram); if (!this.gl.getProgramParameter(shaderProgram, this.gl.LINK_STATUS)) throw new Error(`Shader linking failed: ${this.gl.getError()}`); this.setShaderProgram(shaderProgram); } setupAlignmentBuffer() { if (!this.inputFormat) return; if (this.inputPitch === this.inputWidth * this.inputFormat.depth / BITS_PER_BYTE) { this.alignedData = null; } else { this.alignedData = new this.inputFormat[TYPED_VIEW](this.inputWidth * this.inputHeight); } } getAlignedData() { if (!this.alignedData) return this.inputData; let height = this.inputHeight; let byteLength = this.inputFormat.depth / BITS_PER_BYTE; let sourceRowSize = this.inputPitch / byteLength; let destinationRowSize = this.inputWidth; let source = this.inputData; let destination = this.alignedData; let sourceIndex = 0; let destinationIndex = 0; for (let y = 0; y &lt; height; ++y) { for (let t = 0; t &lt; destinationRowSize; ++t) destination[destinationIndex + t] = source[sourceIndex + t]; sourceIndex += sourceRowSize; destinationIndex += destinationRowSize; } return this.alignedData; } updateViewport() { let inputWidth = Math.max(1, this.inputWidth); let inputHeight = Math.max(1, this.inputHeight); let outputWidth = Math.max(1, this.outputWidth); let outputHeight = Math.max(1, this.outputHeight); if (outputWidth === null &amp;&amp; outputHeight === null) { outputWidth = inputWidth; outputHeight = inputHeight; } if (outputWidth === null) outputWidth = inputWidth * (outputHeight / inputHeight); if (outputHeight === null) outputHeight = inputHeight * (outputWidth / inputWidth); let widthRatio = outputWidth / inputWidth; let heightRatio = outputHeight / inputHeight; let ratio = Math.min(widthRatio, heightRatio); let viewportWidth = widthRatio / ratio; let viewportHeight = heightRatio / ratio; if (this.canvas) { this.canvas.width = outputWidth; this.canvas.height = outputHeight; } if (this.gl.resize) this.gl.resize(outputWidth, outputHeight); let matrix = this.createOrthoMatrix(-viewportWidth, viewportWidth, -viewportHeight, viewportHeight, -RENDER_DEPTH, RENDER_DEPTH); this.gl.uniformMatrix4fv(this.uMatrixLocation, false, matrix); this.gl.uniform2f(this.uInputResolutionLocation, inputWidth, inputHeight); this.gl.uniform2f(this.uOutputResolutionLocation, outputWidth, outputHeight); this.gl.uniform2f(this.uViewportResolutionLocation, viewportWidth * inputWidth, viewportHeight * inputHeight); this.gl.viewport(0, 0, outputWidth, outputHeight); } draw() { this.gl.clear(this.gl.COLOR_BUFFER_BIT); if (!this.inputData || this.inputWidth === 0 || this.inputHeight === 0) return; let format = this.gl[this.inputFormat[GL_FORMAT]]; let type = this.gl[this.inputFormat[GL_TYPE]]; let data = this.getAlignedData(); let textureIndex = this.textureIndex++ % 2; this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures[textureIndex]); this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGB, this.inputWidth, this.inputHeight, 0, format, type, data); this.gl.bindBuffer(this.vertexIndexBuffer.bufferTarget, this.vertexIndexBuffer); this.gl.drawElements(this.gl.TRIANGLE_STRIP, this.vertexIndexBuffer.itemCount, this.gl.UNSIGNED_SHORT, 0); } } × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Classes Classes AggregateInput AnimationFrameTimer AsyncTimer ImmediateTimer KeyboardInput ManualInput NullAudio NullInput NullScreen NullTimer SerialTimer WebGLScreen × Search results Close "},"interfaces.list.html":{"id":"interfaces.list.html","title":"Interfaces","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Interfaces Classes AggregateInput AnimationFrameTimer AsyncTimer ImmediateTimer KeyboardInput ManualInput NullAudio NullInput NullScreen NullTimer SerialTimer WebGLScreen × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer × Search results Close "},"AggregateInput.html":{"id":"AggregateInput.html","title":"Class: AggregateInput","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Class: AggregateInput AggregateInput new AggregateInput(sources) An AggregateInput is an input device that combines multiple other inputs together. Parameters: Name Type Argument Description sources Array.&lt;Input&gt; &lt;optional&gt; The initial sources used for the aggregate. Implements: Input Source: inputs/AggregateInput.js, line 12 Methods addSource(input) Add a new input source inside the aggregate. Parameters: Name Type Description input Input The input to aggregate. Source: inputs/AggregateInput.js, line 28 getState(port, code) Returns true if any of the aggregated input should return true. Parameters: Name Type Description port number The input slot controller. code number The input slot code. Implements: Input#getState Source: inputs/AggregateInput.js, line 69 pollInputs() Simultaneously poll each aggregated input. Implements: Input#pollInputs Source: inputs/AggregateInput.js, line 54 removeSource(input) Remove an input source from the aggregate. Parameters: Name Type Description input Input The input to remove. Source: inputs/AggregateInput.js, line 43 × Search results Close "},"AnimationFrameTimer.html":{"id":"AnimationFrameTimer.html","title":"Class: AnimationFrameTimer","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Class: AnimationFrameTimer AnimationFrameTimer new AnimationFrameTimer() An AnimationFrameTimer is timer device that makes use of the requestAnimationFrame/cancelAnimationFrame API from modern browsers to trigger asynchronous ticks. Source: timers/AnimationFrameTimer.js, line 11 × Search results Close "},"AsyncTimer.html":{"id":"AsyncTimer.html","title":"Class: AsyncTimer","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Class: AsyncTimer AsyncTimer new AsyncTimer(options) An AsyncTimer is an asynchronous timer device. You can use it to run your emulator without blocking your main thread. However, unless you really want to implement a new asynchronous device on top of a new API, you're probably looking for AnimationFrameTimer for browser environments, or ImmediateTimer for Node.js environments. Parameters: Name Type Argument Description options object &lt;optional&gt; The timer options. Properties Name Type Argument Description prepare function &lt;optional&gt; The callback that will schedule the next cycle cancel function &lt;optional&gt; The callback that will abort the next cycle Implements: Timer Source: timers/AsyncTimer.js, line 20 See: AnimationFrameTimer ImmediateTimer Methods &lt;protected&gt; cancel() This method should be specialized, either via subclassing, or by passing the proper parameter when instanciating the timer. Source: timers/AsyncTimer.js, line 150 cancelTick(handler) An engine will call this function if it wants to prevent a scheduled function from being executed. Parameters: Name Type Description handler Opaque The handler returned by Timer#nextTick. Implements: Timer#cancelTick Source: timers/Timer.js, line 16 nextTick(fn) An engine will call this function if it wants to schedule a function to be called at the next tick. Parameters: Name Type Description fn function The function that should be registered. Implements: Timer#nextTick Source: timers/Timer.js, line 6 Returns: handler Type Opaque &lt;protected&gt; prepare() This method should be specialized, either via subclassing, or by passing the proper parameter when instanciating the timer. Source: timers/AsyncTimer.js, line 136 start(beginning, ending) Start the timer. Parameters: Name Type Argument Description beginning function &lt;optional&gt; An optional function that will be called before each tick. ending function &lt;optional&gt; An optional function that will be caled after each tick. Implements: Timer#start Source: timers/Timer.js, line 25 stop() Stop the timer. Implements: Timer#stop Source: timers/Timer.js, line 35 × Search results Close "},"Audio.html":{"id":"Audio.html","title":"Interface: Audio","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Interface: Audio Audio Source: audio/Audio.js, line 1 Methods setInputFormat(format) An engine will call this function to inform the device of the new input format. Throw an exception if the audio device doesn't support the new input format. Parameters: Name Type Description format AudioInputFormat The new input format. Source: audio/Audio.js, line 17 validateInputFormat(format) An engine will call this function to check if the device supports the specified input format. Return true if the audio device supports the specified input format. Parameters: Name Type Description format AudioInputFormat The input format to validate. Source: audio/Audio.js, line 6 × Search results Close "},"ImmediateTimer.html":{"id":"ImmediateTimer.html","title":"Class: ImmediateTimer","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Class: ImmediateTimer ImmediateTimer new ImmediateTimer() An ImmediateTimer is a timer device that makes use of the setImmediate/clearImmediate API from Node to trigger aynchronous ticks. Source: timers/ImmediateTimer.js, line 11 × Search results Close "},"Input.html":{"id":"Input.html","title":"Interface: Input","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Interface: Input Input Source: inputs/Input.js, line 1 Methods getState(port, code) An engine will call this function to check the current state of a specified input. The function will return true if the input is currently active (pressed), and false otherwise. Parameters: Name Type Description port number The input controller port. code number The input code. Source: inputs/Input.js, line 15 pollInputs() An engine will call this function to inform the device that it should update the input state. It means that the devices should never update the input state by themselves, but rather wait for the engine order. It is also important that the update is done synchronously, so that right after returning, the engines are able to call Input#getState. Source: inputs/Input.js, line 6 × Search results Close "},"KeyboardInput.html":{"id":"KeyboardInput.html","title":"Class: KeyboardInput","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Class: KeyboardInput KeyboardInput new KeyboardInput(options) A KeyboardInput is an input device that will monitor the keystrokes on a specified DOM element and transmit those actions to the engines. Parameters: Name Type Argument Description options object &lt;optional&gt; The device options. Properties Name Type Argument Description element Element &lt;optional&gt; The element on which will be bound the DOM listeners. keyMap KeyMap &lt;optional&gt; The initial key map. Implements: Input Source: inputs/KeyboardInput.js, line 44 Members &lt;readonly&gt; element :Element This value contains the element on which the DOM listeners have been bound. Type: Element Source: inputs/KeyboardInput.js, line 54 &lt;readonly&gt; keyMap :KeyMap This value contains the current key map used to filter keys. Type: KeyMap Source: inputs/KeyboardInput.js, line 64 Methods getState(port, code) An engine will call this function to check the current state of a specified input. The function will return true if the input is currently active (pressed), and false otherwise. Parameters: Name Type Description port number The input controller port. code number The input code. Implements: Input#getState Source: inputs/Input.js, line 15 pollInputs() An engine will call this function to inform the device that it should update the input state. It means that the devices should never update the input state by themselves, but rather wait for the engine order. It is also important that the update is done synchronously, so that right after returning, the engines are able to call Input#getState. Implements: Input#pollInputs Source: inputs/Input.js, line 6 setCodeMap() Source: inputs/KeyboardInput.js, line 130 setElement() Change the element on which are bound the DOM listeners. Source: inputs/KeyboardInput.js, line 80 setKeyMap(keyMap) Set the key map that will be used to translate key codes into inputs. Any old key that doesn't map to the same input anymore will be automatically released. Parameters: Name Type Description keyMap KeyMap The new key map. Source: inputs/KeyboardInput.js, line 104 × Search results Close "},"ManualInput.html":{"id":"ManualInput.html","title":"Class: ManualInput","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Class: ManualInput ManualInput new ManualInput(options) A ManualInput is an input device that will transmit any state you manually set from a Javascript API. It's a strictly better NullInput, that works on any environment while still giving you a way to trigger some events when you need to. Parameters: Name Type Argument Description options object &lt;optional&gt; The device options. Properties Name Type Argument Description codeMap object &lt;optional&gt; The initial code map. Implements: Input Source: inputs/ManualInput.js, line 13 Members &lt;readonly&gt; codeMap :object This value contains the current code map used to translate codes. Type: object Source: inputs/ManualInput.js, line 23 Methods down(port, code) Set an input slot as being pressed. Parameters: Name Type Description port number The input slot controller port. code number The input slot code. Source: inputs/ManualInput.js, line 54 getState(port, code) An engine will call this function to check the current state of a specified input. The function will return true if the input is currently active (pressed), and false otherwise. Parameters: Name Type Description port number The input controller port. code number The input code. Implements: Input#getState Source: inputs/Input.js, line 15 pollInputs() An engine will call this function to inform the device that it should update the input state. It means that the devices should never update the input state by themselves, but rather wait for the engine order. It is also important that the update is done synchronously, so that right after returning, the engines are able to call Input#getState. Implements: Input#pollInputs Source: inputs/Input.js, line 6 setCodeMap(codeMap) Set the code map that will be used to translate input codes from one to another. Parameters: Name Type Description codeMap object The new input map. Source: inputs/ManualInput.js, line 38 up(port, code) Set an input slot as being released. Parameters: Name Type Description port number The input slot controller port. code number The input slot code. Source: inputs/ManualInput.js, line 71 × Search results Close "},"NullAudio.html":{"id":"NullAudio.html","title":"Class: NullAudio","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Class: NullAudio NullAudio new NullAudio() A NullAudio is an audio device that won't play anything. Implements: Audio Source: audio/NullAudio.js, line 10 Methods setInputFormat(format) An engine will call this function to inform the device of the new input format. Throw an exception if the audio device doesn't support the new input format. Parameters: Name Type Description format AudioInputFormat The new input format. Implements: Audio#setInputFormat Source: audio/Audio.js, line 17 validateInputFormat(format) An engine will call this function to check if the device supports the specified input format. Return true if the audio device supports the specified input format. Parameters: Name Type Description format AudioInputFormat The input format to validate. Implements: Audio#validateInputFormat Source: audio/Audio.js, line 6 × Search results Close "},"NullInput.html":{"id":"NullInput.html","title":"Class: NullInput","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Class: NullInput NullInput new NullInput() A NullInput is an input device that will never transmit any key as pressed. Even if you don't want any fancy keyboard support or similar, ManualInput is probably a better candidate than NullInput since the later allows you to programmatically trigger key events should you need to, whereas NullInput will never ever do anything. Implements: Input Source: inputs/NullInput.js, line 10 Methods getState(port, code) An engine will call this function to check the current state of a specified input. The function will return true if the input is currently active (pressed), and false otherwise. Parameters: Name Type Description port number The input controller port. code number The input code. Implements: Input#getState Source: inputs/Input.js, line 15 pollInputs() An engine will call this function to inform the device that it should update the input state. It means that the devices should never update the input state by themselves, but rather wait for the engine order. It is also important that the update is done synchronously, so that right after returning, the engines are able to call Input#getState. Implements: Input#pollInputs Source: inputs/Input.js, line 6 × Search results Close "},"NullScreen.html":{"id":"NullScreen.html","title":"Class: NullScreen","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Class: NullScreen NullScreen new NullScreen() A NullScreen is a screen device that doesn't actually render anything. It might be useful if you want to run an engine on Node. Implements: Screen Source: screens/NullScreen.js, line 10 Members &lt;readonly&gt; inputData :* This value contains the data that the screen is currently rendering. Use Screen#setInputData to change it. Type: * Implements: Screen#inputData Source: screens/Screen.js, line 52 &lt;readonly&gt; inputFormat :ScreenInputFormat This value contains the input format that the screen is expecting to render. Use Screen#setInputFormat to change it. Type: ScreenInputFormat Implements: Screen#inputFormat Source: screens/Screen.js, line 41 &lt;readonly&gt; inputHeight :number This value contains the height of the input that the screen is expecting to render. Use Screen#setInputSize to change it. Type: number Implements: Screen#inputHeight Source: screens/Screen.js, line 17 &lt;readonly&gt; inputPitch :number This value contains the pitch of the input that the screen is expecting to render. The pitch is the actual amount of data in a pixel row. Some engines add extra data after each row in order to align the data size. Use Screen#setInputSize to change it. Type: number Implements: Screen#inputPitch Source: screens/Screen.js, line 28 &lt;readonly&gt; inputWidth :number This value contains the width of the input that the screen is expecting to render. Use Screen#setInputSize to change it. Type: number Implements: Screen#inputWidth Source: screens/Screen.js, line 6 &lt;readonly&gt; outputHeight :number This value contains the output height of the rendered data. Use Screen#setOutputSize to change it. Type: number Implements: Screen#outputHeight Source: screens/Screen.js, line 74 &lt;readonly&gt; outputWidth :number This value contains the output width of the rendered data. Use Screen#setOutputSize to change it. Type: number Implements: Screen#outputWidth Source: screens/Screen.js, line 63 Methods flushScreen() Render the input data on the screen. Implements: Screen#flushScreen Source: screens/Screen.js, line 139 setInputData(data) An engine will call this function to inform the device of the new input data. Parameters: Name Type Description data * The new input data. Implements: Screen#setInputData Source: screens/Screen.js, line 120 setInputFormat(format) An engine will call this function to inform the device of the new input format. Throw an exception if the screen device doesn't support the new input format. Parameters: Name Type Description format ScreenInputFormat The new input format. Implements: Screen#setInputFormat Source: screens/Screen.js, line 109 setInputSize(width, height, pitch) An engine will call this function to inform the device of the new input size. Parameters: Name Type Argument Description width number The new input width. height number The new input height. pitch number &lt;optional&gt; The new input pitch. Implements: Screen#setInputSize Source: screens/Screen.js, line 85 setOutputSize(width, height) Change the output size. Parameters: Name Type Description width number The new output width. height number The new output height. Implements: Screen#setOutputSize Source: screens/Screen.js, line 129 validateInputFormat(format) An engine will call this function to check if the device supports the specified input format. Return true if the screen device supports the specified input format. Parameters: Name Type Description format ScreenInputFormat The input format to validate. Implements: Screen#validateInputFormat Source: screens/Screen.js, line 96 Returns: Type bool × Search results Close "},"NullTimer.html":{"id":"NullTimer.html","title":"Class: NullTimer","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Class: NullTimer NullTimer new NullTimer() A NullTimer is a timer device that will never tick. You probably don't want to use it. If you're looking for a synchronous timer, check SerialTimer instead. If you're looking for an asynchronous timer that works on Node.js, check ImmediateTimer instead. If you're looking for a synchronous timer that works on Node.js, check SerialTimer instead. Implements: Timer Source: timers/NullTimer.js, line 12 See: SerialTimer Methods cancelTick(handler) An engine will call this function if it wants to prevent a scheduled function from being executed. Parameters: Name Type Description handler Opaque The handler returned by Timer#nextTick. Implements: Timer#cancelTick Source: timers/Timer.js, line 16 nextTick(fn) An engine will call this function if it wants to schedule a function to be called at the next tick. Parameters: Name Type Description fn function The function that should be registered. Implements: Timer#nextTick Source: timers/Timer.js, line 6 Returns: handler Type Opaque start(beginning, ending) Start the timer. Parameters: Name Type Argument Description beginning function &lt;optional&gt; An optional function that will be called before each tick. ending function &lt;optional&gt; An optional function that will be caled after each tick. Implements: Timer#start Source: timers/Timer.js, line 25 stop() Stop the timer. Implements: Timer#stop Source: timers/Timer.js, line 35 × Search results Close "},"Screen.html":{"id":"Screen.html","title":"Interface: Screen","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Interface: Screen Screen Source: screens/Screen.js, line 1 Members &lt;readonly&gt; inputData :* This value contains the data that the screen is currently rendering. Use Screen#setInputData to change it. Type: * Source: screens/Screen.js, line 52 &lt;readonly&gt; inputFormat :ScreenInputFormat This value contains the input format that the screen is expecting to render. Use Screen#setInputFormat to change it. Type: ScreenInputFormat Source: screens/Screen.js, line 41 &lt;readonly&gt; inputHeight :number This value contains the height of the input that the screen is expecting to render. Use Screen#setInputSize to change it. Type: number Source: screens/Screen.js, line 17 &lt;readonly&gt; inputPitch :number This value contains the pitch of the input that the screen is expecting to render. The pitch is the actual amount of data in a pixel row. Some engines add extra data after each row in order to align the data size. Use Screen#setInputSize to change it. Type: number Source: screens/Screen.js, line 28 &lt;readonly&gt; inputWidth :number This value contains the width of the input that the screen is expecting to render. Use Screen#setInputSize to change it. Type: number Source: screens/Screen.js, line 6 &lt;readonly&gt; outputHeight :number This value contains the output height of the rendered data. Use Screen#setOutputSize to change it. Type: number Source: screens/Screen.js, line 74 &lt;readonly&gt; outputWidth :number This value contains the output width of the rendered data. Use Screen#setOutputSize to change it. Type: number Source: screens/Screen.js, line 63 Methods flushScreen() Render the input data on the screen. Source: screens/Screen.js, line 139 setInputData(data) An engine will call this function to inform the device of the new input data. Parameters: Name Type Description data * The new input data. Source: screens/Screen.js, line 120 setInputFormat(format) An engine will call this function to inform the device of the new input format. Throw an exception if the screen device doesn't support the new input format. Parameters: Name Type Description format ScreenInputFormat The new input format. Source: screens/Screen.js, line 109 setInputSize(width, height, pitch) An engine will call this function to inform the device of the new input size. Parameters: Name Type Argument Description width number The new input width. height number The new input height. pitch number &lt;optional&gt; The new input pitch. Source: screens/Screen.js, line 85 setOutputSize(width, height) Change the output size. Parameters: Name Type Description width number The new output width. height number The new output height. Source: screens/Screen.js, line 129 validateInputFormat(format) An engine will call this function to check if the device supports the specified input format. Return true if the screen device supports the specified input format. Parameters: Name Type Description format ScreenInputFormat The input format to validate. Source: screens/Screen.js, line 96 Returns: Type bool × Search results Close "},"SerialTimer.html":{"id":"SerialTimer.html","title":"Class: SerialTimer","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Class: SerialTimer SerialTimer new SerialTimer() A SerialTimer is a synchronous timer device. You can use it to run your emulator synchronously (ie. blocking the main thread). It also has the ability to only run a finite number of ticks before returning, which is quite valuable when debugging engines. Implements: Timer Source: timers/SerialTimer.js, line 15 Methods cancelTick(handler) An engine will call this function if it wants to prevent a scheduled function from being executed. Parameters: Name Type Description handler Opaque The handler returned by Timer#nextTick. Implements: Timer#cancelTick Source: timers/Timer.js, line 16 nextTick(fn) An engine will call this function if it wants to schedule a function to be called at the next tick. Parameters: Name Type Description fn function The function that should be registered. Implements: Timer#nextTick Source: timers/Timer.js, line 6 Returns: handler Type Opaque one() Start the emulator. Run a single cycle then exit. Source: timers/SerialTimer.js, line 93 start(beginning, ending) Start the timer. Parameters: Name Type Argument Description beginning function &lt;optional&gt; An optional function that will be called before each tick. ending function &lt;optional&gt; An optional function that will be caled after each tick. Implements: Timer#start Source: timers/Timer.js, line 25 stop() Stop the timer. Implements: Timer#stop Source: timers/Timer.js, line 35 × Search results Close "},"Timer.html":{"id":"Timer.html","title":"Interface: Timer","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Interface: Timer Timer Source: timers/Timer.js, line 1 Methods cancelTick(handler) An engine will call this function if it wants to prevent a scheduled function from being executed. Parameters: Name Type Description handler Opaque The handler returned by Timer#nextTick. Source: timers/Timer.js, line 16 nextTick(fn) An engine will call this function if it wants to schedule a function to be called at the next tick. Parameters: Name Type Description fn function The function that should be registered. Source: timers/Timer.js, line 6 Returns: handler Type Opaque start(beginning, ending) Start the timer. Parameters: Name Type Argument Description beginning function &lt;optional&gt; An optional function that will be called before each tick. ending function &lt;optional&gt; An optional function that will be caled after each tick. Source: timers/Timer.js, line 25 stop() Stop the timer. Source: timers/Timer.js, line 35 × Search results Close "},"WebGLScreen.html":{"id":"WebGLScreen.html","title":"Class: WebGLScreen","body":" Virtjs Classes AggregateInputAnimationFrameTimerAsyncTimerImmediateTimerKeyboardInputManualInputNullAudioNullInputNullScreenNullTimerSerialTimerWebGLScreen Interfaces AudioInputScreenTimer Class: WebGLScreen WebGLScreen new WebGLScreen(options) A WebGLScreen is a screen device that uses a WebGL canvas as rendering target. Note that you can also use a headless-gl instance as rendering context, in which case you can simply pass null as canvas parameter. Parameters: Name Type Argument Description options object &lt;optional&gt; The screen options. Properties Name Type Argument Description canvas CanvasElement &lt;optional&gt; The target canvas. glOptions object &lt;optional&gt; The extra option used to setup the WebGL context. glBuilder function &lt;optional&gt; A factory that will build the WebGL context. Implements: Screen Source: screens/WebGLScreen.js, line 92 Members &lt;readonly&gt; canvas :CanvasElement The target canvas on which will be rendered the input data. Type: CanvasElement Source: screens/WebGLScreen.js, line 102 &lt;readonly&gt; gl :WebGLRenderingContext The WebGL context used to render the input data. Type: WebGLRenderingContext Source: screens/WebGLScreen.js, line 112 &lt;readonly&gt; inputData :* This value contains the data that the screen is currently rendering. Use Screen#setInputData to change it. Type: * Implements: Screen#inputData Source: screens/Screen.js, line 52 &lt;readonly&gt; inputFormat :ScreenInputFormat This value contains the input format that the screen is expecting to render. Use Screen#setInputFormat to change it. Type: ScreenInputFormat Implements: Screen#inputFormat Source: screens/Screen.js, line 41 &lt;readonly&gt; inputHeight :number This value contains the height of the input that the screen is expecting to render. Use Screen#setInputSize to change it. Type: number Implements: Screen#inputHeight Source: screens/Screen.js, line 17 &lt;readonly&gt; inputPitch :number This value contains the pitch of the input that the screen is expecting to render. The pitch is the actual amount of data in a pixel row. Some engines add extra data after each row in order to align the data size. Use Screen#setInputSize to change it. Type: number Implements: Screen#inputPitch Source: screens/Screen.js, line 28 &lt;readonly&gt; inputWidth :number This value contains the width of the input that the screen is expecting to render. Use Screen#setInputSize to change it. Type: number Implements: Screen#inputWidth Source: screens/Screen.js, line 6 &lt;readonly&gt; outputHeight :number This value contains the output height of the rendered data. Use Screen#setOutputSize to change it. Type: number Implements: Screen#outputHeight Source: screens/Screen.js, line 74 &lt;readonly&gt; outputWidth :number This value contains the output width of the rendered data. Use Screen#setOutputSize to change it. Type: number Implements: Screen#outputWidth Source: screens/Screen.js, line 63 Methods flushScreen() Render the input data on the screen. Implements: Screen#flushScreen Source: screens/Screen.js, line 139 setInputData(data) An engine will call this function to inform the device of the new input data. Parameters: Name Type Description data * The new input data. Implements: Screen#setInputData Source: screens/Screen.js, line 120 setInputFormat(format) An engine will call this function to inform the device of the new input format. Throw an exception if the screen device doesn't support the new input format. Parameters: Name Type Description format ScreenInputFormat The new input format. Implements: Screen#setInputFormat Source: screens/Screen.js, line 109 setInputSize(width, height, pitch) An engine will call this function to inform the device of the new input size. Parameters: Name Type Argument Description width number The new input width. height number The new input height. pitch number &lt;optional&gt; The new input pitch. Implements: Screen#setInputSize Source: screens/Screen.js, line 85 setOutputSize(width, height) Change the output size. Parameters: Name Type Description width number The new output width. height number The new output height. Implements: Screen#setOutputSize Source: screens/Screen.js, line 129 validateInputFormat(format) An engine will call this function to check if the device supports the specified input format. Return true if the screen device supports the specified input format. Parameters: Name Type Description format ScreenInputFormat The input format to validate. Implements: Screen#validateInputFormat Source: screens/Screen.js, line 96 Returns: Type bool × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
